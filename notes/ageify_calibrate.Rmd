---
title: "Calibrating the 'ageified' model"
author: "Irena Papst"
date: "Last updated: `r format(Sys.time(), '%d %b %Y at %H:%M')`"
output: html_document
---

```{r setup}
devtools::load_all()
library(tidyverse)
```

We want to be able to calibrate $\beta$ in the age-structured model, but trying to fit a $\beta$ value for each age group may be too difficult (or impossible). Let's see how far we can get with $\beta$ calibrated to the whole population.

# Simple calibration for constant $\beta$

## Idea

We can break $\beta_0$ down into two components: transmissiblity, $\tau$ (proportion of contacts between $S$ and $I$ that lead to transmission) and the average contact rate $\langle c \rangle$ (contacts/day):

$$
\beta_0 = \tau \langle c \rangle.
$$

In the age-structured model, if we assume transmissibility is constant across age groups, we have

$$
(\beta_0)_i = \tau c_i
$$

for each age group $i$. Instead of calibrating each $(\beta_0)_i$, let's try to:

1. estimate $\beta_0$ for the entire population via calibration;
2. calculate $\tau$ using the estimated $\beta_0$ and the calculated $\langle c \rangle$ from the assumed $c_i$ in the age-structured model, yielding $(\beta_0)_i$ for each age group.

Here's a function that does this lazy calibration:

```{r calibrate_transmission}
#' Calibrate age-specific transmission params using population-level beta0 and assumed contact structure
#'
#' @param age_params parameters that have been initialized using `expand_params_age()` with a specified age-specific contact rate
#' @param base_beta0 beta0 calibrated from base (non-ageified) simulation
#'
#' @return an object of class `params_pansim`
#' @export
#'
#' @examples
#' base_params <- update(read_params("PHAC_testify.csv"), testing_intensity = 0, beta0 = 2)
#' age_params <- expand_params_age(base_params, transmissibility = 1, contact_rate_age = rep(4, length(age_cat)))
#' calibrate_transmission(age_params)
calibrate_transmission <- function(age_params, base_beta0){
  ## calculate average age-specific contact rate
  avg_contact_rate_age <- sum(age_params[["N"]]*age_params[["contact_rate_age"]])/sum(age_params[["N"]])
  
  ## calculate transmissibility implied by average contact rate
  transmissibility <- base_beta0/avg_contact_rate_age
  print(paste0("calculated transmissibility: ", transmissibility))
  
  ## update beta0 (and transmissibility in age_params)
  ## based on assumed contact_rate_age and implied transmissibility
  age_params[["beta0"]] <- transmissibility*age_params[["contact_rate_age"]]
  age_params[["transmissibility"]] <- transmissibility
  
  return(age_params)
}
```

Here's a function that computes both the base sim, as well as the ageified sim (with lazy calibration):

```{r compare_age_to_base}
#' Compare ageified simulation to base, using simple calibration trick
#'
#' @param age_cat age categories
#' @param base_beta0 beta0 to use in base simulation
#' @param Nvec population distribution
#' @param pmat contact probability matrix
#' @param contact_rate_age age-specific contact rates
#'
#' @return
#' @export
compare_age_to_base <- function(age_cat,
                                base_beta0,
                                Nvec,
                                pmat = NULL,
                                contact_rate_age){
  
  ## set up base (non-ageified) params and state
  base_params <- update(read_params("PHAC_testify.csv")
                        , N = sum(Nvec)
                        , testing_intensity = 0
                        , beta0 = base_beta0
                        )
  base_state <- make_state(N = base_params[["N"]],
                           E0 = length(age_cat))
  end_date <- "2020-08-01"
  
  ## run base simulation
  res_base <- run_sim(base_params, base_state, condense = FALSE,
                      end_date = end_date)
  
  ## set up ageified parameters 
  ## (this will use assume beta0 as in the base simulation)
  age_params <- expand_params_age(
    params = base_params,
    age_cat = age_cat,
    Nvec = Nvec,
    pmat = pmat,
    transmissibility = 1, ## dummy value, will get updated
    contact_rate_age = contact_rate_age
  )
  
  ## perform lazy calibration (update transmissibility based on base_beta0
  ## and contact_rate_age)
  age_params <- calibrate_transmission(age_params, base_beta0)
  
  ## set up age-structured state
  age_state <- expand_state_age(
    base_state,
    age_cat = age_cat,
    Nvec = age_params[["N"]]
  )
  
  ## age-structured sim with beta0 vec and transmissibility
  ## "inferred" from base sim
  res_age <- run_sim(age_params, age_state,
                    condense = FALSE,
                    end_date = end_date)
  
  ## aggregate over ages
  res_age_cond <- condense_age(res_age %>% select(-foi))
  attr(res_age_cond, "row.names") <- as.character(attr(res_age_cond, "row.names"))
  
  ## check sim results are equal
  print("comparing base and ageified simulation results... equal?")
  print(all.equal(res_age_cond,
                   res_base %>% select(-foi)))
  
  ## plot sim results
  p <- (bind_rows(
    pivot_longer((res_base 
      %>% select(-foi) 
      %>% mutate(model = "base")),
    cols = -c(date, model),
    names_to = "var"),
    pivot_longer((condense_age(res_age %>% select(-foi))
      %>% mutate(model = "age-structured")),
    cols = -c(date, model),
    names_to = "var"))
    %>% mutate(var = as_factor(var))
    %>% ggplot(aes(x = date, y = value, color = model))
    + geom_line()
    + facet_wrap(vars(var), scales = "free_y")
    + scale_x_date(date_breaks = "1 month",
                   date_labels = "%b")
  ) 

  print(p)
  
}
```

## Demo with a uniform population, uniform contact strucutre

This should work perfectly...

```{r compare_res_uu}
## set up age categories
age_cat <- mk_agecats(0, 80, da = 30)
n <- length(age_cat)
Ni <- 1e6
Nvec <- rep(Ni, n)
base_beta0 <- 2

compare_age_to_base(
  age_cat = age_cat,
  base_beta0 = base_beta0,
  Nvec = Nvec,
  contact_rate_age = rep(4, length(age_cat))
)
```
Not shocking; if this wasn't a perfect match, it would be because of a bug.

## Uniform population, non-uniform contact structure

```{r compare_res_un}
Nvec <- rep(5e6, 3)
true_beta0 <- c(2, 3, 3/2)

base_beta0 <- sum(Nvec*true_beta0)/sum(Nvec)
true_transmissibility <- 0.5
contact_rate_age <- true_beta0/true_transmissibility

## initialize contact structure
pmat <- matrix(c(4/10, 4/30, 8/15,
                 2/10, 23/30, 3/15,
                 4/10, 1/10, 4/15),
               nrow = 3,
               dimnames = list(age_cat, age_cat))

compare_age_to_base(
  age_cat = age_cat,
  base_beta0 = base_beta0,
  Nvec = Nvec,
  pmat = pmat,
  contact_rate_age = contact_rate_age
)
```
Not a perfect match, but it looks like there's pretty good agreement...

## Demo with a non-uniform population, non-uniform contact structure

```{r res_nn, eval = FALSE}
## rescale to a non-uniform population while still maintaining balance
total_contacts <- true_beta0*Nvec
true_beta0 <- 1:3
Nvec <- total_contacts/true_beta0

## check balance
# isSymmetric((Nvec*true_beta0)*pmat)

base_beta0 <- sum(Nvec*true_beta0)/sum(Nvec)
true_transmissibility <- 0.5
contact_rate_age <- true_beta0/true_transmissibility

compare_age_to_base(
  age_cat = age_cat,
  base_beta0 = base_beta0,
  Nvec = Nvec,
  pmat = pmat,
  contact_rate_age = contact_rate_age
)
```
Again, not terrible... not sure how sensitive the match is to the population distribution, relative magnitudes of the true $\beta0_i$, and the assumed $pmat$.

# Simple calibration with time-varying $\beta$

# Simple calibration for Ontario case reports
