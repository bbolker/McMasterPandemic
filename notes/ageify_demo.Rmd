---
title: "Ageify demo"
author: "Irena Papst"
date: "Last updated: `r format(Sys.time(), '%d %b %Y at %H:%M')`"
output: html_document
---

```{r setup, message = FALSE, echo = FALSE}
knitr::opts_chunk$set(echo = FALSE)

devtools::load_all()
library(tidyverse)
library(patchwork)
```

```{r prep_res_for_plotting}
prep_res_for_plotting <- function(res, drop_states = NULL){
  (res  
    %>% select(-c(foi))
    %>% pivot_longer(-date)
    %>% separate(name, into = c("state", "age_cat"),
                 sep = "_", extra = "merge")
    %>% mutate(state = as_factor(state))
   ## fix age labels
    %>% mutate(age_cat = str_replace(age_cat, "\\.$", "\\+"))
    %>% mutate(age_cat = str_replace(age_cat, "\\.", "-"))
  ) -> res
  
  if(!is.null(drop_states)){
    res <- res %>% filter(!(state %in% drop_states))
  }
  
  return(res)
}
```

```{r plot_res_by_age}
plot_res_by_age <- function(res, drop_states = NULL){
  (prep_res_for_plotting(res, drop_states)
    %>% ggplot(aes(x = date, y = value, colour = state))
    + geom_line()
    + facet_wrap(vars(age_cat))
    + scale_x_date(date_breaks = "1 month",
                   date_labels = "%b")
  ) -> gg
  
  return(gg)
}
```

```{r plot_res_by_state}
plot_res_by_state <- function(res, drop_states = NULL){
  (prep_res_for_plotting(res, drop_states)
    %>% ggplot(aes(x = date, y = value, colour = age_cat))
    + geom_line()
    + facet_wrap(vars(state), scales = "free_y")
    + scale_x_date(date_breaks = "1 month",
                   date_labels = "%b")
  ) -> gg
  
  return(gg)
}
```

# Synthetic contact structure

## Homogeneous mixing

To reduce the ageified model to the case of homogenous mixing, we need to set:

1. $\beta_i = \beta$ for all $i$: constant contact rate (and transmission probability) across age groups (default in the software if only one $\beta_i$ is provided),
1. $N_i = \frac{N}{n}$ for all $i$: uniform population distribution across age groups (default in the software if only one $N$ is provided; this is assumed to be the total population size),
1. $P_{ij} = \frac{1}{n}$ for all $i,j$: uniform distribution of contacts across age groups.

In other words, we need to have a uniform population distribution and uniform contact structure.

(`tests/testthat/test-ageify.R` includes a check to ensure that the homogeneous case of the age-structured model reduces down to the base simulation.)

```{r sim_setup_basic}
base_params <- update(read_params("PHAC_testify.csv")
                      , testing_intensity=0
                      , beta0 = 2
                      )
base_state <- make_state(N = base_params[["N"]],
                         E0 = length(mk_agecats()))
end_date <- "2020-06-01"
```

```{r compare_res_uu_with_homog}
res_uu <- run_sim_ageify(base_params, base_state, condense = FALSE,
                         end_date = end_date)

res_hom <- run_sim(base_params, base_state, condense = FALSE,
                   end_date = end_date)

res_uu_cond <- condense_age(res_uu %>% select(-foi))

attr(res_uu_cond, "row.names") <- as.character(attr(res_uu_cond, "row.names"))

expect_equal(res_uu_cond,
             res_hom %>% select(-foi))

p1 <- plot(condense_age(res_uu %>% select(-foi))) + labs(title = "age-structured model")
p2 <- plot(res_hom %>% select(-foi)) + labs(title = "base model")

(p1 / p2) + plot_layout(guides = "collect")
```

## Uniform population distribution, non-uniform contact pattern

```{r res_un}
age_cat <- mk_agecats(0, 80, da = 30)
n <- length(age_cat)

beta0 <- c(2, 3, 3/2)
pmat <- matrix(c(4/10, 4/30, 8/15,
                 2/10, 23/30, 3/15,
                 4/10, 1/10, 4/15),
               nrow = 3,
               dimnames = list(age_cat, age_cat))

Nvec <- rep(10000, 3)
base_params <- update(base_params,
                      N = sum(Nvec))
base_state <- make_state(N = sum(Nvec), E0 = n)

res_un <- run_sim_ageify(base_params, base_state,
                         age_cat = age_cat,
                         beta0 = beta0,
                         pmat = pmat,
                         Nvec = Nvec,
                         condense = FALSE,
                         end_date = end_date)
```

```{r plot_res_un}
drop_states <- c("S", "R")
(plot_res_by_age(res_un, drop_states)
  + labs(
    title = "uniform population distribution, non-uniform contact pattern")
  ) 
plot_res_by_state(res_un, drop_states)
```

## Using a diagonal contact matrix

(There's also a test written with this contact matrix, checking whether identical epidemics are generated within each age group.)

```{r, eval = FALSE}
pmat_d <- mk_pmat(dist = "diag")
res_ud <- run_sim_ageify(base_params, base_state, 
                         pmat = pmat_d, end_date = end_date, condense = FALSE)
```

## Using a "compound" contact matrix

```{r other_cmats, eval = FALSE, echo = FALSE}
## case 2: diagonal (mixing only within age groups)
pmat_diag <- diag(n)

## case 3: predominantly mixing within age categories
pmat_compound <- (pmat_unif + pmat_diag)/rowSums(pmat_unif + pmat_diag)
```

## Using a Mistry *et al.* contact matrix

Here's a demo using the Mistry *et al.* contact matrix for Ontario:

```{r sim_setup_mistry, eval = FALSE}
age_cat <- mk_agecats(0, 84, 10)
M <- mk_mistry_pmat(age_cat = age_cat)
M_bar <- rowSums(M)
pmat <- M/M_bar
Nvec <- mk_mistry_Nvec(age_cat = age_cat)$pop

## update state so that population size matches to new distribution
state <- base_state
state[["S"]] <- sum(Nvec) - length(age_cat)
state[["E"]] <- length(age_cat)
state[!grepl("^S|^E", names(state))] <- 0

mistry_beta <- 0.5
beta0vec <- mistry_beta*M_bar

res_mistry <- run_sim_ageify(base_params, state,
                             age_cat = age_cat,
                             beta0vec = beta0vec,
                             pmat = pmat,
                             Nvec = Nvec,
                             condense = FALSE,
                             end_date = end_date)

(prep_res_for_plotting(res_mistry)
  %>% mutate(state = fct_recode(state,
    I = "Ia",
    I = "Ip",
    I = "Im",
    I = "Is"
  ))  
  %>% group_by(date, state, age_cat)
  %>% summarise(value = sum(value), .groups = "drop")
  %>% filter(state %in% c("S", "E", "I", "X", "R", "D"))
) -> res_mistry_cond

(res_mistry_cond
  %>% ggplot(aes(x = date, y = value, colour = state))
    + geom_line()
    + scale_y_continuous(
      labels = scales::label_number_si()
      )
    + facet_wrap(vars(age_cat))
    + labs(
        title = "Ontario contact data and population distribution")
) 

(res_mistry_cond
    %>% ggplot(aes(x = date, y = value, colour = age_cat))
    + geom_line()
    + scale_y_continuous(
      labels = scales::label_number_si()
      )
    + facet_wrap(vars(state), scales = "free_y")
  )
```

# Using $\beta(t)$ calibrated to overall pop in age-specific sims

<!----------------------------------------------------------------------------->

```{r old, eval = FALSE, echo = FALSE}
## READ INITIAL PARAMETERS (for base sim)
pp <- update(read_params("PHAC_testify.csv"), testing_intensity=0)

## SET UP STATE (for base sim)
## make state vector
ss <- make_state(params=pp)

## AGEIFY
## expand state to include age categories
n <- 4 # number of age categories
ss2 <- expand_stateval_age(ss,
                           age_cat = mk_agecats(min = 1, max = n, da = 1))
## pull out age categories
aa <- attr(ss2, "age_cat")

## construct uniform contact matrix (homogeneous mixing)
pmat_unif <- matrix(1/n, nrow=n, ncol=n, dimnames=list(aa,aa))
print("contact matrix:")
Matrix::image(Matrix(pmat_unif))

## expand parameters to include contact matrix
ppa_unif <- c(as.list(pp), list(pmat=pmat_unif))

## MAKE AGEIFIED BETA VECTOR
beta_unif <- make_beta(ss2, ppa_unif, full=FALSE)
print("betavec:")
Matrix::image(Matrix(beta_unif))

## MAKE AGEIFIED RATE MATRIX
M <- make_ratemat(ss2, ppa_unif, sparse=TRUE)
print("ratemat:")
show_ratemat(M)

## set end date for simulations
end_date <- "2021-02-15"
```



