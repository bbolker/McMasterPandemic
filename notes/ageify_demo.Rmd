---
title: "Ageify demo"
author: "Irena Papst"
date: "Last updated: `r format(Sys.time(), '%d %b %Y at %H:%M')`"
output: html_document
---

```{r setup, message = FALSE}
library(tidyverse)
devtools::load_all()
library(patchwork)
```

```{r prep_res_for_plotting}
prep_res_for_plotting <- function(res){
  (res  
    %>% select(-c(foi))
    %>% pivot_longer(-date)
    %>% separate(name, into = c("state", "age_cat"),
                 sep = "_", extra = "merge")
    %>% mutate(state = as_factor(state))
   ## fix age labels
    %>% mutate(age_cat = str_replace(age_cat, "\\.$", "\\+"))
    %>% mutate(age_cat = str_replace(age_cat, "\\.", "-"))
  ) -> res
  
  return(res)
}
```

```{r plot_res_by_age}
plot_res_by_age <- function(res){
  (prep_res_for_plotting(res)
    %>% ggplot(aes(x = date, y = value, colour = state))
    + geom_line()
    + facet_wrap(vars(age_cat))
  ) -> gg
  
  return(gg)
}
```

```{r plot_res_by_state}
plot_res_by_state <- function(res){
  (prep_res_for_plotting(res)
    %>% ggplot(aes(x = date, y = value, colour = age_cat))
    + geom_line()
    + facet_wrap(vars(state), scales = "free_y")
  ) -> gg
  
  return(gg)
}
```

# Simulation demo

## Homogeneous mixing

To reduce the ageified model to the case of homogenous mixing, we need to set:

1. $\beta_i = \beta$ for all $i$: constant contact rate (and transmission probability) across age groups (default in the software if only one $\beta_i$ is provided),
1. $N_i = \frac{N}{n}$ for all $i$: uniform population distribution across age groups (default in the software if only one $N$ is provided; this is assumed to be the total population size),
1. $P_{ij} = \frac{1}{n}$ for all $i,j$: uniform distribution of contacts across age groups.

Ageify tests include a check to ensure that the homogeneous case of the age-structured model reduces down to the base simulation. The test passes when $\beta_0 = 1$, but fails for other values... Let's try to get to the bottom of this:

```{r sim_setup_basic}
base_params <- update(read_params("PHAC_testify.csv"),
                      testing_intensity=0
                      # , beta0 = 2
                      )
base_state <- make_state(params = base_params)
## make it so that there is one exposed person in each age class, to start (for a completely homogeneous simulation)
base_state[["S"]] <- sum(base_state) - length(mk_agecats())
base_state[["E"]] <- length(mk_agecats())
base_state[!grepl("^S|^E", names(base_state))] <-  rep(0, length(base_state)-2)

end_date <- "2020-07-01"
```

```{r}
run_sim_ageify(base_params, base_state,
               condense = FALSE,
               end_date = end_date)
```


```{r compare_res_uu_with_homog}
res_uu <- run_sim_ageify(base_params, base_state, condense = FALSE,
                         end_date = end_date)

res_hom <- run_sim(base_params, base_state, condense = FALSE,
                   end_date = end_date)

res_uu_cond <- condense_age(res_uu %>% select(-foi))

attr(res_uu_cond, "row.names") <- as.character(attr(res_uu_cond, "row.names"))

expect_equal(res_uu_cond,
             res_hom %>% select(-foi))

p1 <- plot(condense_age(res_uu %>% select(-foi))) + labs(title = "age-structured model")
p2 <- plot(res_hom %>% select(-foi)) + labs(title = "base model")

(p1 / p2) + plot_layout(guides = "collect")
```

OK, these results are identical now, but `test-ageify.R` is failing... population total check is failing.

## Other scenarios 

Here's a demo of simulations with age-varying transmission:

```{r plot_res_uu}
(plot_res_by_age(res_uu)
  + labs(
    title = "uniform population distribution, uniform contacts, constant beta")
  )
plot_res_by_state(res_uu)
```

```{r plot_res_ur, eval = FALSE}
res_ur <- run_sim_ageify(base_params, base_state,
                         pmat = mk_pmat(dist = "rand"),
                         condense = FALSE,
                         end_date = end_date)

(plot_res_by_age(res_ur)
  + labs(
    title = "uniform population distribution, random contacts, random beta0")
  ) 
plot_res_by_state(res_ur)
```

```{r plot_res_ru}
res_ru <- run_sim_ageify(base_params, base_state,
                         Nvec = mk_Nvec(dist = "rand"),
                         condense = FALSE,
                         end_date = end_date)

(plot_res_by_age(res_ru)
  + labs(
    title = "random population distribution, uniform contacts, constant beta0")
  ) 
plot_res_by_state(res_ru)
```

```{r plot_res_rr, eval = FALSE}
res_rr <- run_sim_ageify(base_params, base_state,
                         Nvec = mk_Nvec(dist = "rand"),
                         pmat = mk_pmat(dist = "rand"),
                         condense = FALSE,
                         end_date = end_date)

(plot_res_by_age(res_rr)
  + labs(
    title = "random population distribution, random contacts, random beta0")
  ) 
plot_res_by_state(res_rr)
```

## Using a diagonal contact matrix

(There's also a test written with this contact matrix, checking whether identical epidemics are generated within each age group.)

```{r, eval = FALSE}
pmat_d <- mk_pmat(dist = "diag")
res_ud <- run_sim_ageify(base_params, base_state, 
                         pmat = pmat_d, end_date = end_date, condense = FALSE)
```

## Using a "compound" contact matrix

```{r other_cmats, eval = FALSE, echo = FALSE}
## case 2: diagonal (mixing only within age groups)
pmat_diag <- diag(n)

## case 3: predominantly mixing within age categories
pmat_compound <- (pmat_unif + pmat_diag)/rowSums(pmat_unif + pmat_diag)
```

## Using a Mistry *et al.* contact matrix

Here's a demo using the Mistry *et al.* contact matrix for Ontario:

```{r sim_setup_mistry, eval = FALSE}
age_cat <- mk_agecats(0, 84, 10)
M <- mk_mistry_pmat(age_cat = age_cat)
M_bar <- rowSums(M)
pmat <- M/M_bar
Nvec <- mk_mistry_Nvec(age_cat = age_cat)$pop

## update state so that population size matches to new distribution
state <- base_state
state[["S"]] <- sum(Nvec) - length(age_cat)
state[["E"]] <- length(age_cat)
state[!grepl("^S|^E", names(state))] <- 0

mistry_beta <- 0.5
beta0vec <- mistry_beta*M_bar

res_mistry <- run_sim_ageify(base_params, state,
                             age_cat = age_cat,
                             beta0vec = beta0vec,
                             pmat = pmat,
                             Nvec = Nvec,
                             condense = FALSE,
                             end_date = end_date)

(prep_res_for_plotting(res_mistry)
  %>% mutate(state = fct_recode(state,
    I = "Ia",
    I = "Ip",
    I = "Im",
    I = "Is"
  ))  
  %>% group_by(date, state, age_cat)
  %>% summarise(value = sum(value), .groups = "drop")
  %>% filter(state %in% c("S", "E", "I", "X", "R", "D"))
) -> res_mistry_cond

(res_mistry_cond
  %>% ggplot(aes(x = date, y = value, colour = state))
    + geom_line()
    + scale_y_continuous(
      labels = scales::label_number_si()
      )
    + facet_wrap(vars(age_cat))
    + labs(
        title = "Ontario contact data and population distribution")
) 

(res_mistry_cond
    %>% ggplot(aes(x = date, y = value, colour = age_cat))
    + geom_line()
    + scale_y_continuous(
      labels = scales::label_number_si()
      )
    + facet_wrap(vars(state), scales = "free_y")
  )
```

# Using $\beta(t)$ calibrated to overall pop in age-specific sims

<!----------------------------------------------------------------------------->

```{r old, eval = FALSE, echo = FALSE}
## READ INITIAL PARAMETERS (for base sim)
pp <- update(read_params("PHAC_testify.csv"), testing_intensity=0)

## SET UP STATE (for base sim)
## make state vector
ss <- make_state(params=pp)

## AGEIFY
## expand state to include age categories
n <- 4 # number of age categories
ss2 <- expand_stateval_age(ss,
                           age_cat = mk_agecats(min = 1, max = n, da = 1))
## pull out age categories
aa <- attr(ss2, "age_cat")

## construct uniform contact matrix (homogeneous mixing)
pmat_unif <- matrix(1/n, nrow=n, ncol=n, dimnames=list(aa,aa))
print("contact matrix:")
Matrix::image(Matrix(pmat_unif))

## expand parameters to include contact matrix
ppa_unif <- c(as.list(pp), list(pmat=pmat_unif))

## MAKE AGEIFIED BETA VECTOR
beta_unif <- make_beta(ss2, ppa_unif, full=FALSE)
print("betavec:")
Matrix::image(Matrix(beta_unif))

## MAKE AGEIFIED RATE MATRIX
M <- make_ratemat(ss2, ppa_unif, sparse=TRUE)
print("ratemat:")
show_ratemat(M)

## set end date for simulations
end_date <- "2021-02-15"
```



