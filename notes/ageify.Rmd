---
title: "age examples"
---

**tl;dr** 

- *Good news*: we can build structures that seem to make sense, and basic stuff runs without crashing
- *Bad news*: need to spend more time thinking about scaling/normalization of contact matrices, age structure etc.. Age-structured runs that should be *identical* to homogeneous mixing results aren't, quite ... ??

```{r pkgs,message=FALSE}
library(McMasterPandemic)
library(Matrix)
library(cowplot)
library(tidyverse)
library(directlabels)
```

Read regular parameters, make normal (non-testify, non-expanded) parameters

```{r utils, echo=FALSE}

tot_I <- function(x) sum(x[grep("^I[a-z]",names(x))])
ifun <- function(M,sub="") {
    Matrix::image(Matrix(M),scales=list(y=list(at=seq(nrow(M)),labels=rownames(M)),
                                        x=list(at=seq(ncol(M)),labels=colnames(M), rot=90)),
                  xlab="",ylab="",
                  sub=sub)
}
```

```{r setup1}
pp <- update(read_params("PHAC_testify.csv"), testing_intensity=0)
ss <- make_state(params=pp)
```

Expand the state vector by age categories (by default, ten-year bins up to 91+)
```{r expand_state}
ss2 <- expand_stateval_age(ss)
## hack so we have an infective
ss2["Im_11-20"] <- 1
ss2["E_91+"] <- 0
head(ss2)
tail(ss2)
```

We need to define a cross-age contact matrix. 

* Eventually we should take it from that study (referenced somewhere in the notes) that estimated contact matrices for a variety of countries.
* for now I'm going to define two, one simple "compound symmetric" matrix (1 on the diagonal, 0.1 off-diagonal) and one diagonal. 
* with equal parameters across age categories, what contact matrices will give exactly equal to dynamics to homogeneous mixing? All-equal and diagonal?


```{r Cmats}
aa <- mk_agecats()
## compound symmetric
Cmat <- matrix(0.1, nrow=length(aa), ncol=length(aa), dimnames=list(aa,aa))
diag(Cmat) <- 1
## diagonal
Cmat.d <- diag(length(aa))*10
dimnames(Cmat.d) <- dimnames(Cmat)
## uniform
Cmat.u <- matrix(1, nrow=length(aa), ncol=length(aa), dimnames=list(aa,aa))
```

At present the indicator for whether the machinery should be run in an
age-structured way or not is the presence/absence of a `Cmat` component in the parameters (now a list
rather than a vector)

Beta "vector" (now a matrix): including only infectious compartments (could also use `full=TRUE`)
```{r beta_vec_etc}
ppa <- c(as.list(pp),list(Cmat=Cmat))
b1 <- make_betavec(ss2, ppa, full=FALSE)
ppa.d <- c(as.list(pp),list(Cmat=Cmat.d))
ppa.u <- c(as.list(pp),list(Cmat=Cmat.u))
b1.d <- make_betavec(ss2, ppa.d, full=FALSE)
plot_grid(ifun(b1,sub="compound"),ifun(b1.d,sub="diag"),nrow=2)
```

Expanded rate matrix: `make_ratemat` bases its categories on the names of the state vector.

```{r make_ratemat}
M <- make_ratemat(ss2, ppa, sparse=TRUE) ## some NA values??
show_ratemat(M)
```

Try `run_sim_range()` [lowest-level/simplest simulation engine]
```{r run_sim_range, warning=FALSE}
rr <- run_sim_range(ppa.u, ss2, nt=200)
par(las=1,bty="l")
matplot(rr[,1],rr[,-1],lty=1,type="l",log="y",xlab="time (days)",ylab="")
```

Try `run_sim`

```{r run_sim}
rr2 <- run_sim(ppa.u, ss2,end_date="2020-10-01",condense=FALSE)
plot(rr2,log=TRUE)+theme(legend.position="none")
```

```{r comp_sims}
pp_list <- list(ppa,ppa.d,pp,ppa.u)
ss_list <- list(ss2,ss2,ss,ss2)
nm <- c("compound","diag","non_age","unif")
sims <- map2(pp_list,ss_list, ~run_sim(.x,.y, end_date="2020-10-01"))
names(sims) <- nm
ks <- c("H","ICU","hosp","death","D")
simplots <- map2(sims,names(sims), ~plot(.x,log=TRUE,log_lwr=1e-3,
                                         keep_states=ks)+ggtitle(.y))
plot_grid(plotlist=simplots,nrow=2)
```

- "compound" example is badly scaled (uniform should just work, and diag example is scaled to keep effective pop sizes the same)
- in these plots we're automatically "condensing" everything, so age categories get aggregated before plotting.  Of course we don't have to (and could write some alternative plot methods that show time X age class grids)
- age-struc runs are missing foi/report/cumRep, because foi is needed to compute report and cumRep and we're not storing foi for age struc right now
- diag and unif are not *identical* to homogeneous run: visually OK at first glance, but hosp is noticeably different, and closer inspection shows that they're all slightly different

## tests

Summing over flows should give exactly the same answer for uniform and non-age-structured models
(rounding-induced changes in initial conditions??
```{r}
ss0 <- condense_age(ss2)
sim0 <- run_sim(pp, ss0, end_date="2020-10-01")
res2 <- (map_dfr(list(homog=sim0, unif=sims$unif), pivot, .id="model")
    %>% filter(var %in% c("I","H","D","S"))
)
gg1 <- (ggplot(res2, aes(date,value,colour=var,linetype=model))
      + geom_line()
      + scale_y_log10()
)
print(gg1+ facet_wrap(~var,scale="free"))
res2 %>% arrange(date,var) %>% tail()
```

OK, there really is a difference - smallest in I, but still there. Go back to one-step flows ...

```{r echo=FALSE}
check_flows <- function(state, params, ratemat) {
    ratemat <- update_ratemat(ratemat, state, params)
    dt <- 1
    flows <- sweep(ratemat, state, MARGIN=1, FUN="*")*dt
    x_states <- c("X","N","P")                  ## weird parallel accumulators
    x_regex <- sprintf("^(%s)_",paste(x_states,collapse="|"))
    ## all states that are *not* weird parallel accumulators
    p_states <- grep(x_regex,names(state),invert=TRUE,value=TRUE)
    outflow <- rowSums(flows[,p_states])
    inflow <-  colSums(flows)
    return(list(outflow=outflow[outflow>0], inflow=inflow[inflow>0]))
}
nz <- function(x) x[x>0]
```

I'm getting stuck. Try all this again with fewer categories (two, to be precise):

```{r agecat2}
aa2 <- mk_agecats(min=1,max=100,da=50)
print(aa2)
```

Re-do everything with homogeneous mixing, with only two age categories

```{r agecat2B,warning=FALSE}
Cmat.2u <- matrix(1, nrow=length(aa2), ncol=length(aa2), dimnames=list(aa2,aa2))
ppa.2u <- c(as.list(pp),list(Cmat=Cmat.2u))
ss2cat <- expand_stateval_age(ss, age_cat=aa2)
ss02 <- condense_age(ss2cat)
sim2cat <- run_sim(ppa.2u,ss2cat, end_date="2020-10-01")
sim00 <- run_sim(pp, ss02, end_date="2020-10-01")
res2cat <- (map_dfr(list(homog=sim00, unif=sim2cat), pivot, .id="model")
    %>% filter(var %in% c("I","H","D","S"))
)
gg1 %+% res2cat
```

We still see differences (I has some tiny differences too, just not visible on this scale)

Dig into individual components, being a little careful to use starting state vectors that
don't suffer from rounding-induced differences ...

```{r comp}
## make rate matrices
M0 <- make_ratemat(ss02, pp, sparse=TRUE)  ## non-age flow matrix
M.2u <- make_ratemat(ss2cat, ppa.2u, sparse=TRUE)
step1 <-  do_step(ss2cat, ppa.2u, M.2u)
step1C <- condense_age(step1)
step0 <-  do_step(ss02, pp, M0)
```

The state after the first step is different, but the same up to numeric fuzz:

```{r comp2}
all(step0==step1C)  ## FALSE
all.equal(step0,step1C)  ## TRUE!
all.equal(step0,step1C, tolerance=0)
```

```{r comp3}
stopifnot(ppa.2u["beta0"]==pp["beta0"])
stopifnot(all(nz(ss0)==nz(condense_age(ss2))))  ## starting points are the same
bb <- make_betavec(ss2cat, ppa.2u, full=FALSE)
bb1 <- make_betavec(ss2cat, ppa.2u, full=TRUE)
b0 <- make_betavec(ss0, pp, full=FALSE)
b1 <- make_betavec(ss0, pp, full=TRUE)
update_foi(ss02,pp,b1)
update_foi(ss2cat,ppa.2u, beta_vec=bb1)
all.equal(check_flows(ss0,pp,M0),
          lapply(check_flows(ss2,ppa.u,Mu),
                 function(x) nz(condense_age(x,levels=rownames(M0)))))
```

Where do they diverge? Plot differences over time between non-age and uniform age (after collapsing):

```{r diffs, warning=FALSE}
mdiff_fun  <- function(x,y) {
    (map_dfr(list(age=x,nonage=y),
        ~ select(., -c(foi,incidence,report,cumRep)) %>% pivot(),
        .id="model")
    %>% group_by(date,var)
    %>% arrange(model)
    %>% summarise(diff=abs(diff(value)),.groups="drop")
    )
}
mdiff1 <- mdiff_fun(sim2cat,sim00)
gg2 <- direct.label(ggplot(mdiff1,aes(date,diff,colour=var))+ geom_line() + geom_point() + scale_y_log10() ,
                    "last.bumpup")
print(gg2)
```

Try starting conditions that let us find the difference faster??

```{r warning=FALSE,message=FALSE}
ss2cat2 <- ss2cat
EIpos <- grep("^(E|I[a-z])",names(ss2cat2))
ss2cat2[EIpos] <- 1
ss2cat2[grep("^S",names(ss2cat2))] <- (pp["N"] - sum(ss2cat2[EIpos]))/2
ss03 <- condense_age(ss2cat2)
sim2cat2 <- run_sim(ppa.2u,ss2cat2, end_date="2020-10-01")
sim02 <- run_sim(pp, ss03, end_date="2020-10-01")
plot_grid(gg2 %+% mdiff_fun(sim2cat2,sim02),
          gg2 %+% mdiff_fun(sim2cat2,sim02) + scale_y_continuous()
          )
```

Focus on the start:

```{r startdiff,warning=FALSE}
print(gg2 %+% head(mdiff_fun(sim2cat2,sim02),40))
```

OK, total I differs by more than 0.1 after the first step: that seems big enough to pursue.

```{r}
all.equal(cc1 <- check_flows(ss03,pp,M0),
          cc1a <- lapply(check_flows(ss2cat2,ppa.2u,M.2u),condense_age))
zapsmall(abs(cc1$outflow-cc1a$outflow))  ## outflow from Is differs???
```


## to do

- test individual steps etc. in uniform `Cmat` case to track down differences
- implement age-dependent N in state construction ...
- try non-homogeneous parameters across age classes; should work to make params a list and replace some of the scalar/length-1 elements with vectors [if params is a list, should test: all elements should be (1) vector of length 1 or (2) vector of length `n_age` or (3) `n_age * n_age` matrix
- foi stuff: time to implement an incidence accumulator and derive foi from it rather than storing foi on the fly? Do we want to store age-structured foi?
- see how we do if we try to testify an age-structured matrix etc ...
- clean up make_betavec: do we ever need "full"??
