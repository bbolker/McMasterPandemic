% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calibrate.R
\name{calibrate_comb}
\alias{calibrate_comb}
\title{top-level calibration based on mobility, splines, phenom het}
\usage{
calibrate_comb(
  data,
  params,
  opt_pars = NULL,
  mob_data = NULL,
  mob_breaks = NULL,
  mob_breaks_int = FALSE,
  mob_logist_scale = NA,
  spline_days = 14,
  spline_setback = 0,
  spline_extrap = c("linear", "constant"),
  spline_df = NA,
  knot_quantile_var = NA,
  spline_pen = 0,
  spline_type = "bs",
  testing_data = NULL,
  maxit = 10000,
  skip.hessian = FALSE,
  use_DEoptim = TRUE,
  DE_cores = 1,
  use_mobility = FALSE,
  use_phenomhet = FALSE,
  use_spline = FALSE,
  use_testing = FALSE,
  vars = NULL,
  debug_plot = interactive(),
  debug = FALSE,
  debug_hist = FALSE,
  return_val = c("fit", "X", "formula", "args", "time_args"),
  ...
)
}
\arguments{
\item{data}{a data set to compare to, containing date/var/value (current version assumes that only a single state var is included)}

\item{params}{parameters}

\item{opt_pars}{starting parameters (and structure).  Parameters that are part of the \code{params_pansim} parameter vector can be specified within the \code{params} element (with prefixes if they are transformed); other parameters can include distributional parameters or time-varying parameters}

\item{mob_data}{mobility data}

\item{mob_breaks}{vector of breakpoints for piecewise mobility
model}

\item{mob_breaks_int}{(logical) specifies whether the intercept of
the mobility/transmission relationship changes at each
mobility breakpoint. The default (\code{FALSE}) specifies that
mobility in 'mobility period' \code{i} is
\code{beta0*(rel_mobility)^p_i}; \code{TRUE} would specify
\code{beta0*(a_i)*(rel_mobility)^p_i}, with \code{a_1==1}.}

\item{mob_logist_scale}{specifies the scale of the smooth
(logistic) transition between mobility periods, in days: if it
is \code{NA} (default), the model uses sharp breaks for a
piecewise-constant model.  Otherwise, the parameter used makes
a logistic transition between the two periods with the
specified scale.}

\item{spline_days}{days between spline knots}

\item{spline_setback}{days before end of time series to set boundary knots for spline
(this implies \emph{linear} extrapolation after knots if \code{spline_type="ns"} is specified,
which is probably wise)}

\item{spline_extrap}{spline extrapolation model ("linear" or "constant")}

\item{spline_df}{overall spline degrees of freedom}

\item{knot_quantile_var}{variable to use cum dist for knotspacing}

\item{spline_pen}{penalization for spline}

\item{spline_type}{spline type ("ns" for natural spline or "bs" for b-spline)}

\item{testing_data}{data frame with columns containing dates (\code{Date}) and testing intensity (\code{intensity}) (= tests per capita per day)}

\item{maxit}{maximum iterations for Nelder-Mead/optimization step}

\item{skip.hessian}{skip Hessian calculation?}

\item{use_DEoptim}{use differential evolution as first stage?}

\item{DE_cores}{number of parallel workers for DE}

\item{use_mobility}{include mobility as a covariate in the model?}

\item{use_phenomhet}{include phenomenological heterogeneity?}

\item{use_spline}{include spline?}

\item{use_testing}{include variation in testing intensity?}

\item{vars}{which vars to use? (default is all in data)}

\item{debug_plot}{plot debugging curves? (doesn't work with parallel DEoptim)}

\item{debug}{print debugging messages?}

\item{debug_hist}{keep information on parameter history?}

\item{return_val}{"fit" (return calibrated value); "X" (short-circuit/return model matrix?); "formula" (return log-linear formula for time-varying beta)}

\item{...}{extra args}
}
\description{
top-level calibration based on mobility, splines, phenom het
}
\examples{
if (require(dplyr)) {
  dd <- ont_all \%>\% trans_state_vars() \%>\%
       filter(var \%in\% c("H","report"))
 params <- read_params("ICU1.csv")
 ## quick and dirty example (maximize speed)
 calibrate_comb(data=dd, params=params,
               use_spline=TRUE,
              maxit=10, skip.hessian=TRUE, use_DEoptim =FALSE)
X <-  calibrate_comb(data=dd, params=params,
              use_spline=TRUE,
              spline_type="ns",
              spline_setback=1,
              spline_extrap="constant",
              return_val="X")
matplot(X, ylab="")
form <-  calibrate_comb(data=dd, params=params,
              use_spline=TRUE,
              spline_type="ns",
              spline_setback=1,
              spline_extrap="constant",
              return_val="formula")
print(form)
}
}
